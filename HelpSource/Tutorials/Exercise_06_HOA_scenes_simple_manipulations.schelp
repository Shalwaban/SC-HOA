title:: HOA Tutorial Exercise 06
summary:: monitoring (decoding) b format sounds
categories:: Libraries>HOA
related:: Guides/HOAguide, Guides/HOAguide


STRONG:: Previous:::
link::Tutorials/Exercise_05_HOA_b_format_file_playback::

STRONG:: Next:::
link::Tutorials/Exercise_07_HOA_beamforming::


The examples below demonstarte how to use the classes

LIST::
## link::Classes/HOATransMirror:: - mirror the sound field along x,y or z.
## link::Classes/HOATransRotateAz:: - rotate the soundfield around the z axis.
::

code::
s.quit
(
ServerOptions.devices;
s = Server.local;
Server.local = Server.default;
o = Server.local.options; // Get the local server's options
o.numInputBusChannels = 2; // Set Input to number of Inputs
o.numOutputBusChannels = 36; // lets start after chan 36 so as not to see the mic input
o.numAudioBusChannels = 2048;
o.blockSize = 512;
o.numWireBufs = 1024 * 16;
o.memSize = 2.pow(18);
o.sampleRate = 48000;
s.makeWindow;
s.boot;
)


(
~order = 3;
~hoaNumChannels = (~order+1).pow(2);
// make an oszilloscope showing all the channels for the order from above
s.scope(2);
)

~hoaSoundFile = Buffer.read(s, "/Users/floriangrond/Library/Application Support/SuperCollider/Extensions/HOA/HelpSource/Tutorials/eigen_ACN_N3D_CIRMMT_Foyer_short.wav");


~hoaSoundFile.numChannels;

// Let's make a node that generates a HOA signal ( white noise ) control the direction with the mouse.
// we won't see it since we don't monitor it.
(
~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);
~hoaSignal.source = { HPF.ar(PlayBuf.ar( ~hoaSoundFile.numChannels,  ~hoaSoundFile, loop:1  ), 100)   };
~hoaSignal.fadeTime = 1;
)

(
~hoaTransformer = NodeProxy.new(s, \audio, ~hoaNumChannels);
~hoaTransformer.source = {|front_back =1, left_right = 0, up_down = 0| var in; in = \in.ar(0!~hoaNumChannels); HOATransMirror.ar(~order, in, front_back, left_right, up_down) };
~hoaTransformer.fadeTime = 1;
)

~hoaTransformer.source = {|front_back =1, left_right = 0, up_down = 0| var in; in = \in.ar(0!~hoaNumChannels); HOATransMirror.ar(~order, in, front_back, left_right, up_down) };
~hoaTransformer.set(\front_back, 0);
~hoaTransformer.set(\front_back, 1);

~hoaTransformer.set(\left_right, 0);
~hoaTransformer.set(\left_right, 1);

~hoaTransformer.set(\up_down, 0);
~hoaTransformer.set(\up_down, 1);

~hoaTransformer.source = {|front_back =1, left_right = 0, up_down = 0| var in; in = \in.ar(0!~hoaNumChannels); HOATransRotateAz.ar(~order, in, MouseX.kr(0, 360)) };

// Let's make a node that can take in (multichannel) HOA signals.
// now let's load HRIR filters for each of the 26 channels
HOADecLebedev26.loadHrirFilters(s);
HOADecLebedev26.hrirFilters.size;
(
~decoder = NodeProxy.new(s, \audio, 26);
~decoder.source = {var in; in = \in.ar(0!~hoaNumChannels); HOADecLebedev26.ar(3, in, hrir_Filters:1) };
~decoder.fadeTime = 1;
~decoder.play(0, 26);
)

// and we connect them
~hoaSignal <>> ~hoaTransformer  <>>  ~decoder;
::


STRONG:: Previous:::
link::Tutorials/Exercise_05_HOA_b_format_file_playback::

STRONG:: Next:::
link::Tutorials/Exercise_07_HOA_beamforming::
