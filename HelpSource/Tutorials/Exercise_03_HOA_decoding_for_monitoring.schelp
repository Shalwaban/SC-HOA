title:: HOA Tutorial Exercise 03
summary:: Listening (headphone decoding) of b-format soundfiles.
categories:: Libraries>HOA
related:: Guides/HOAguide, Tutorials/HOA_Tutorial_Overview

STRONG:: Previous:::
link::Tutorials/Exercise_02_HOA_converting_SN3D_N3D_FuMa::

STRONG:: Next:::
link::Tutorials/Exercise_04_HOA_plane_versus_spherical_waves::

Having mostly looked at HOA B-format multichannel sounds so far. This exercise is about listening to them.
To this end, the HOA library provides 3 different spherical decoders based on Lebedev Grids
link:: https://en.wikipedia.org/wiki/Lebedev_quadrature::.
Lebedev Grids are equidistant points on sphere, in the case of a decoder they correspond to virtual speaker positions.
Each signal of the virtual speakers is then convolved with corresponding HRIR kernels to yield two headphone signals.


The examples below show how to monitor the playback of HOA b-format via headphones.

In case you have not done so yet: let's start the sound server, which we configure first to get more audio buses and to have 36 output channels

code::
s.quit; // quit the server first if it is still running with another configuration.
(
ServerOptions.devices;
s = Server.local;
Server.local = Server.default;
o = Server.local.options; // Get the local server's options
o.numInputBusChannels = 2; // Set Input to number of Inputs
o.numOutputBusChannels = 36; // lets start after chan 36 so as not to see the mic input
o.numAudioBusChannels = 2048;
o.blockSize = 512;
o.numWireBufs = 1024 * 16;
o.memSize = 2.pow(18);
o.sampleRate = 48000;
s.makeWindow;
s.boot;
)
::

Start the oscilloscope showing all the channels for the selected order of the b-format.

code::
(
~order = 4;
~hoaNumChannels = (~order+1).pow(2);
s.scope(~hoaNumChannels);
)
::

Let's make a node that generates a HOA signal ( white noise ) control the direction with the mouse.
we won't see it since we don't monitor it.

code::
(
~hoaSignal = NodeProxy.new(s, \audio, ~hoaNumChannels);
~hoaSignal.source = {HOAEncPan.ar(~order, WhiteNoise.ar(1), MouseX.kr(0, 360), MouseY.kr(-90, 90 ) )};
~hoaSignal.fadeTime = 1;
)
::

Now let's make a node that can take in (multichannel) HOA signals.

code::
(
~decoder = NodeProxy.new(s, \audio, 26);
~decoder.source = {var in; in = \in.ar(0!(~hoaNumChannels)); in};
~decoder.fadeTime = 1;
~decoder.play(0, 26);
)
::

Still we don't see anything yet in the scope because ~hoaSignal  and ~decoder are not connected yet

code::
~hoaSignal <>> ~decoder;
::

Now you see in the scope the B-format from ~hoaSignal going untransformed through ~decoder.
Here is where the advantages of proxyspace with Ambisonics come is handy.
Lets change the  NodeProxies one step at a time. First the ~hoaSignal itself:

code::
~hoaSignal.source = {HOAEncPan.ar(~order, SinOsc.ar(48000 / 1024), MouseX.kr(0, 360), MouseY.kr(-90, 90 ) )};
~hoaSignal.source = {HOAEncPan.ar(~order, WhiteNoise.ar(1), MouseX.kr(0, 360), MouseY.kr(-90, 90 ) )};
::

Then the decoder, first we decode into a Lebedev Grid with 26 positions, which is enough points for order 3:
code::
s.scope(26); // lets see all channels
~decoder.source = {var in; in = \in.ar(0!~hoaNumChannels); HOADecLebedev26.ar(3, in, output_gains: 24) };
::

Now let's load HRIR filters for each of the 26 channels:

code::
HOADecLebedev26.loadHrirFilters(s);
HOADecLebedev26.hrirFilters.size;
// and change the decoder.source again
~decoder.source = {var in; in = \in.ar(0!~hoaNumChannels); HOADecLebedev26.ar(3, in, hrir_Filters:1) };

// now you might want to change the HOA signal again to hear something
~hoaSignal.source = {HOAEncPan.ar(~order, SinOsc.ar(48000 / 64), MouseX.kr(0, 360), MouseY.kr(-90, 90 ) )};
~hoaSignal.source = {HOAEncPan.ar(~order, WhiteNoise.ar(1), MouseX.kr(0, 360), MouseY.kr(-90, 90 ) )};
::


STRONG:: Previous:::
link::Tutorials/Exercise_02_HOA_converting_SN3D_N3D_FuMa::

STRONG:: Next:::
link::Tutorials/Exercise_04_HOA_plane_versus_spherical_waves::
